# Unix System Programming in OCaml

## 1. Generalities
### 1.1. Modules `Sys` and `Unix`
 `Sys`에는 유닉스나 다른 운영체제에 공통 인터페이스가 담겨 있고
 `Unix`는 유닉스 특화 인터페이스가 담겨 있다.

 각 모듈은 기존의 `Pervasives` 모듈의 식별자를 재정의 하기도
 한다. 예를 들면 `Pervasives.stdin` 이랑 `Unix.stdin`은 다른 타입이다.

### 1.2. Interface with the calling program
 쉘에서 프로그램을 실행하면, 쉘은 *아규먼트*와 *환경*을 프로그램에게
 전달해준다. 아규먼트는 커맨드 라인에서 방금 실행한 프로그램의 커맨드
 이후의 모든 단어들이다. 환경은 `variable=value` 형식을 가진 문자열의
 집합으로, 환경 변수의 글로벌 바인딩을 나타낸다. `csh`에서는 `setenv
 var=val` 으로, `sh` 에서는 `var=val; export var`로 가능하다.

#### `var argv: string array`
 아규먼트는 `Sys.argv`에 문자열 배열로 전달된다.

#### `val environment : unit -> string array`
 프로그램의 환경은 `Unix.environment` 함수로 얻을 수 있다.

#### `val getenv : string -> string`
 환경 변수를 얻는 좀더 편한 방법으로는 `Sys.getenv`가
 있다. `Sys.getenv v`는 변수 `v` 에 연결된 환경 변수 값을 돌려주는데,
 바인딩이 없으면 `Not_found` 예외를 던진다.

 예시는 프로그램의 아규먼트를 출력하는 [에코
 프로그램](sample/ex_1.2_echo.ml)이다.

#### `val exit : int -> 'a`
 인자 `int`는 프로그램을 호출한 프로그램에게 돌려주는 리턴 코드
 값이다. 관습적으로 `0`은 모든 게 잘 됐다는 걸 뜻하고, 그 외의 `0`이
 아닌 코드는 오류라는 신호이다. 조건문에서 `sh` 쉘은 리턴 코드 `0`을
 불리언 값 "True"로 해석하고, 모든 `0`이 아닌 값을 불리언 값 "False"로
 해석한다. 어떤 프로그램이 담고 있는 모든 표현식을 정상적으로 실행하고
 종료한다면, 암묵적으로 `exit 0`을 호출한다. 어떤 프로그램이 중간에
 어떤 예외가 발생했지만 그것을 놓친 채로 종료되면, 암묵적으로 `exit
 2`를 호출한다. `exit` 함수는 항상 (쓰기 위해 열려 있는) 모든 채널의
 버퍼를 비운다 (flush). `at_exit` 함수는 프로그램이 종료할 때 수행할
 다른 동작을 예약 등록할 수 있다.

#### `val at_exit : (unit -> unit) -> unit`
 마지막에 등록한 함수부터 호출된다. 즉, 스택이다. `at_exit`로 등록한
 함수는 등록해제할 수 없다.

### 1.3. Error handling
 특별한 일이 없으면, `Unix` 모듈의 모든 함수는 오류 시에
 `Unix_error`를 던진다.

#### `exception Unix_error of error * string * string`
 두번째 아규먼트는 이 오류를 던진 시스템 콜의 이름이다. 세번째
 아규먼트는 (가능한 경우에만) 오류가 발생한 오브젝트이다. 예를 들어서,
 파일 이름을 아규먼트로 받는 시스템 콜의 경우, 이 파일 이름이 세번째
 아규먼트에 담긴다. 마지막으로 첫번째 아규먼트는 에러 코드로 오류의
 성질을 나타낸다.

#### `type error = E2BIG | EACCES | EAGAIN | ... | EUNKNOWNERR of int`
 이 타입 생성자는 POSIX 표준과 UNIX98, BSD의 오류에 쓰인 이름과 의미를
 따른다. 이외의 모든 오류는 `EUNKOWNERR` 생성자를 쓴다.

 예외의 시맨틱에 따라, 명확하게 예측하지 못해서 `try` 를 이용해
 다뤄지지 않은 오류는 프로그램의 최상단까지 전파되어서 프로그램을
 이르게 종료시켜버린다. 작은 어플리케이션에서는 예측 못한 오류를
 치명적인 오류로 다루는건 좋은 방법이다. 하지만, 에러를 분명하게
 드러내는게 좋다. 이를 위해서 `Unix` 모듈은 아래 함수를 제공한다.

#### `val handle_unix_error : ('a -> 'b) -> 'a -> 'b`
 `handle_unix_error f x`는 함수 `f`를 아규먼트 `x`로 호출한다. 만약
 이게 `Unix_error` 예외를 일으키면, 그 오류를 설명하는 메시지를
 출력하고 프로그램은 `exit 2`로 종료된다. 전형적인 사용법은
 `handle_unix_error prog () ;;` 처럼 `prog : unit -> unit` 함수가
 프로그램의 본체를 실행하는 경우이다. `handle_unix_error` 함수는
 [이렇게](sample/ex_1.3_unix_error.ml) 구현할 수 있다. `prerr_xxx` 류
 함수는 `print_xxx` 함수랑 똑같이 동작하는데 대신 표준출력인
 `stdout`이 아니라 표준오류인 `stderr`에 쓴다.

#### `val error_message : error -> string`
 주어진 오류를 설명하는 메시지를 돌려준다.


### 1.4. Library functions
 시스템 프로그래밍에서는 종종 같은 패턴이 반복된다. 이런 코드를
 본질적으로 줄이기 위해서, 보통은 공통 부분을 빼서 라이브러리로
 만든다.

 완전한 프로그램에서는 어떤 오류가 발생할지 정확하게 아는 반면, 보통
 라이브러리 함수의 경우는 실행 문맥을 제대로 알지 못한다. 그렇다고
 모든 오류가 치명적이라고 가정할 수도 없다. 그러므로 에러가 다시 (그
 에러를 일으킨) 호출자에게 돌아가서, 적절한 행동 방침에 따르는 것이
 좋다. 하지만, 라이브러리 함수는 시스템의 일관된 상태를 유지하기
 위해서, 오류가 그 라이브러리 함수를 빠져나가서 다른 함수로 전달되는게
 보통은 허락되지 않는다. 예를 들어서, 파일을 열어서 그 파일
 디스크립터에게 함수를 적용하는 라이브러리 함수는 모든 경우에 그 파일
 디스크립터를 닫는 일에 신경써야 하는데, 파일에 쓰다가 오류가 나는
 경우도 마찬가지다. 그러지않으면 파일 디스크립터 누수가 발생할 수
 있고, 파일 디스크립터가 고갈될 수 있다.

 게다가, 파일에 적용된 연산은 다른 함수에서 정의될 수도 있는데, 이
 경우 언제 또는 어떻게 실패할지 정확하게 알 수 없다. 그러므로 종종
 "마무리짓는" 코드를 이용해서 작업의 본체를 보호한다. 보통 이런
 "마무리"는 함수가 정상 실행하든 실패하든 리턴하기 직전에 호출되어야
 한다.

 아쉽게도 OCaml은 내장 마무리 문법이 없지만, 다음처럼 쉽게 정의할 순
 있다:

``` ocaml
let try_finalize f x finally y =
  let res = try f x with exn -> finally y; raise exn in
  finally y;
  res
```

## 2. Files
 "파일" 이라는 단어는 여러 타입의 오브젝트를 다룬다:

 * 표준 파일: 텍스트나 바이너리 정보를 담고 있는 바이트의 유한 집합,
   종종 "일반" 파일로 부름.
 * 디렉토리
 * 심볼릭 링크
 * 특수한 파일 (장치): 주로 컴퓨터 주변기기에 접근을 제공함.
 * 이름있는 파이프
 * Unix 도메인에서의 이름있는 소켓


 파일의 컨셉은 파일에 담긴 데이터와 파일의 타입, 접근 권한, 마지막
 수정 시간과 같은 파일 그 자체의 정보 (메타 데이터) 를 모두 포함한다.


### 2.1. The file system
 엄청 요약하면 파일 시스템은 트리로 생각할 수 있다. 루트는 `/` 이고,
 브랜치는 `\000`과 `/`를 제외한 (파일) 이름으로 표현된다 (출력할 수
 없는 문자와 공백을 파일 이름에 쓰지 않는 것은 좋은
 실천이다). 논터미널 노드는 *디렉토리*이다: 이런 노드는 항상 두 개의
 브랜치 `.`과 `..`을 갖고 있는데 각각 그 디렉토리 자체와 그 디렉토리의
 부모를 가리킨다. 다른 노드는 *파일*이라고 부르는데, 이건 좀
 모호하다. 왜냐하면 다른 모든 노드 또한 "파일"이라고 부를 수 있기
 때문에. 그래서 보통은 *논디렉토리 파일 (non-directory files)* 이라고
 부른다.

 트리의 노드는 경로를 통해 다뤄진다. 어떤 경로가 루트로 시작하면 *절대
 경로*라고 하고, 어떤 디렉토리로 시작하면 *상대 경로*라고 한다. 즉,
 *상대 경로*는 경로가 `/` 문자로 구분되는 이름이며, *절대 경로*는
 `/`로 시작하는 상대 경로이다. `/`가 경로 구분자로도 쓰이지만 루트를
 뜻하는데도 쓰이는 것을 주의하자.

 `Filename` 모듈은 포터블한 경로를 다룬다. 예를 들어서, `concat`
 함수는 `/` 문자를 지정하지 않아도 경로를 합치는데, 다른 운영체제
 (예를 들어 윈도우즈에서는 경로 구분자가 `\`이다) 에서도 동일한 동작을
 하도록 해준다. `Filename` 모듈은 문자열 값 `current_dir_name`과
 `parent_dir_name`을 제공하는데 이는 트리에서 `.`과 `..`와
 같다. `basename`과 `dirname` 함수는 경로 `p`가 `d/b`가 같은 파일을
 가리키고 `d`가 그 파일이 있는 디렉토리이고 `b`가 파일일 때, 접두사
 `d`와 접미사 `b`를 돌려준다. `Filename` 모듈의 함수는 오직 경로에
 대해서만 동작한다.

 사실 엄밀히 말하면 파일 계층은 트리가 아니다. 먼저 디렉토리 `.` 는
 디렉토리가 스스로를 가리키도록 해주고, `..`는 어떤 디렉토리에서
 이어지는 경로를 정의하기 위해서 디렉토리 계층에서 하나 위로 이동할 수
 있도록 해준다. 게다가, 논디렉토리 파일은 여러 개의 부모 (*하드 링크*)
 를 가질 수 있다. 마지막으로, *심볼릭 링크*가 있는데 경로를 담은
 논디렉토리 파일이다. 이때 개념적으로는 일반 파일처럼 심볼릭 링크의
 내용을 읽어서 이 경로를 얻을 수 있다. 심볼릭 링크가 경로 중간에
 나타날때마다 그 경로를 투명하게 따라가야 한다. 만약 `s`가 심볼릭
 링크이고 값이 경로 `l` 이면, 경로 `p/s/q`는 (1) `l`이 절대 경로이면
 파일 `l/q`를, (2) `l`이 상대 경로이면 파일 `p/l/q`를 나타낸다.

 보통 파일 계층의 재귀적 탐색은 다음 규칙을 잘 준수하면 끝난다:

  * 디렉토리 `.`과 `..`를 무시한다.
  * 심볼릭 링크를 따라가지 않는다.

 하지만 만약 심볼릭 링크를 따라가면 그래프를 탐색하게 되는데, 이때
 무한루프에 빠지는 것을 막기 위해서는 방문한 노드를 기록해야 한다.

 각각의 프로세스는 현재 작업 디렉토리를 갖고 있다. `getcwd` 함수로
 이걸 확인할 수 있고, `chdir` 함수로 이걸 바꿀 수 있다. 또한 `chroot`
 함수로 파일 계층의 뷰를 제한할 수 있다. `chroot p`를 호출하면 `p`
 (디렉토리여야 한다) 를 새로운 제한된 파일 계층 뷰의 루트로
 지정한다. 그러면 절대 경로는 이 새로운 루트 `p`에 의해
 재해석된다. 당연히 `p` 에서의 `..` 는 `p` 자신이다.


### 2.2. File names and file descriptors
 파일에 접근하는데는 두 가지 방법이 있다. 하나는 파일 계층의 *파일
 이름* 또는 *경로 이름*으로 접근하는 것이다. 하드 링크 탓에, 한 파일은
 여러 개의 이름을 가질 수 있다. 이름은 `string` 타입이다. 예를 들면
 다음 함수들은 파일 이름 레벨에서 동작한다.

``` ocaml
val unlink : string -> unit (** rm -f f *)
val link : string -> string -> unit (** ln f1 f2 , hard link *)
val symlink : string -> string -> unit (** ln -s f1 f2 , symbolic link *)
val rename : string -> string -> unit (** mv f1 f2 *)
```

 파일에 접근하는 두 번째 방법은 파일 디스크립터를 통한 접근이다. 한
 디스크립터는 한 파일을 가리키는 포인터를 나타내고, 추가적으로
 파일에서의 현재 읽기/쓰기 위치, 접근 권한, 읽기/쓰기 행동을 제한하는
 플래그 등의 다른 정보를 갖고 있다. 파일 디스크립터는 추상 타입
 `file_descr` 이다.

 디스크립터를 통한 파일 접근은 이름으로 접근하는 것과는
 독립적이다. 구체적으로 파일 디스크립터를 얻을 때마다, 그 파일은
 삭제되거나 이름이 바뀔 수 있는데, 디스크립터는 여전히 그 파일을
 가리킬 것이다.

 프로그램이 실행되면, 세 개의 디스크립터가 할당되고 각각 `Unix` 모듈의
 `stdin`, `stdout`, `stderr` 변수에 묶인다:

``` ocaml
val stdin : file_descr
val stdout : file_descr
val stderr : file_descr
```

  각각 그 프로세스의 표준입력, 표준출력, 표준오류에 해당한다.

  프로그램이 리다이렉션 없이 커맨드라인으로 실행될 때, 이 세 개의
  디스크립터는 모두 터미널을 가리킨다. 하지만 만약, 예를 들어서 입력이
  `cmd < f` 쉘 표현식 등을 통해 리다이렉션된 경우, `stdin`
  디스크립터는 `cmd` 커맨드가 실행되는 동안 파일 `f`를
  가리킨다. 비슷하게, `cmd > f` 와 `cmd 2> f` 는 각각 `stdout`과
  `stderr`가 파일 `f`를 가리키도록 한다.


### 2.3. Meta-attributes, types and permissions
 `stat`, `lstat`, `fstat` 시스템 콜은 파일의 메타 속성을 알려준다; 즉,
 파일의 내용물이 아니라 파일 그 자체에 대한 정보를 뜻한다. 특히, 이
 정보는 파일의 신원, 타입, 접근 권한, 가장 최근에 접근한 시간과 날짜
 등의 정보를 포함한다.

``` ocaml
val stat : string -> stats
val lstat : string -> stats
val fstat : file_descr -> stats
```

 `stat`과 `lstat`은 파일 이름을 아규먼트로 받고 `fstat`은 파일
 디스크립터를 아규먼트로 받는다. `lstat`은 심볼릭 링크 그 자체에 대한
 정보를 주고 `stat`은 그 심볼릭 링크가 가리키는 실제 파일에 대한
 정보를 준다. 얘네가 돌려주는 정보의 타입 `stats`가 갖고 있는 필드는
 아래 테이블과 같다.

| 필드 이름             | 설명                                                                                                                                                                   |
| ---                   | ---                                                                                                                                                                    |
| `st_dev : int`        | 그 파일이 저장된 장치의 아이디                                                                                                                                         |
| `st_ino : int`        | 그 파일의 파티션에서의 아이디. 즉 inode 번호. `(st_dev, st_ino)` 쌍은 파일 시스템에서 그 파일을 유니크하게 식별한다.                                                   |
| `st_kind : file_kind` | 파일 타입. `S_REG`는 일반파일, `S_DIR`는 디렉토리, `S_CHR`는 캐릭터 장치, `S_BLK`은 블록 장치, `S_LNK`은 심볼릭 링크, `S_FIFO`는 이름있는 파이프, `S_SOCK`은 소켓이다. |
| `st_perm : int`       | 그 파일의 접근 권한                                                                                                                                                    |
| `st_nlink : int`      | 디렉토리의 경우 그 디렉토리 안의 엔트리 개수이고, 그외의 경우는 그 파일을 가리키는 하드 링크의 개수이다.                                                               |
| `st_uid : int`        | 파일 소유 유저의 아이디                                                                                                                                                |
| `st_gid : int`        | 파일 소유 그룹의 아이디                                                                                                                                                |
| `st_rdev : int`       | (특수한 파일의 경우) 연관된 주변기기 아이디                                                                                                                            |
| `st_size : int`       | 파일 사이즈 (바이트 단위)                                                                                                                                              |
| `st_atime : int`      | 가장 마지막 접근 시간 (GMT 1970/01/01 00:00 부터 초 단위로)                                                                                                            |
| `st_mtime : int`      | 가장 마지막 파일 내용 수정 시간 (상동)                                                                                                                                 |
| `st_ctime : int`      | 가장 마지막 파일 상태 수정 시간: 접근 권한, 소유 유저, 소유 그룹, 링크 개수 등                                                                                         |


#### Identification
 파일은 장치 번호 (보통 파일이 위치한 디스크 파티션) `st_dev`와 inode
 번호 `st_ino`의 쌍으로 유니크하게 식별된다.

#### Owners
 하나의 파일은 하나의 소유 유저 `st_uid`와 하나의 소유 그룹 `st_gid`를
 갖는다. 머신의 모든 유저와 그룹에 대한 것은 보통 `/etc/passwd`와
 `/etc/groups`에 있다. 다음과 같은 포터블한 방식으로 이를 살펴볼 수
 있다.

``` ocaml
val getpwnam : string -> passwd_entry
val getgrnam : string -> group_entry
val getpwuid : int -> passwd_entry
val getgrgid : int -> group_entry
```

 실행 중인 프로세스의 사용자 이름과 그 사용자가 속한 모든 그룹은 다음
 함수로 얻을 수 있다:

``` ocaml
val getlogin : unit -> string
val getgroups : unit -> int array
```

 `chown` 시스템 콜은 파일 (첫번째 아규먼트)의 소유 유저(두번째)와 소유
 그룹(세번째)를 바꾼다. 만약 파일 디스크립터를 이용한다면, `fchown`을
 쓰면 된다. 수퍼 유저만 이 정보를 바꿀 수 있다.

``` ocaml
val chown : string -> int -> int -> unit
val fchown : file_descr -> int -> int -> unit
```

#### Access rights
 접근 권한은 정수 비트로 인코딩되고, `file_perm` 타입은 그냥 `int`
 타입과 같다. 이 정수에 스페셜 비트와 소유 유저/소유 그룹/기타 유저의
 읽기/쓰기/실행 권한을 비트 벡터로 표현한다.

```
{Special} {User} {Group} {Other}
--------- ------ ------- -------
0oSUGO
```


 비트는 순서대로 `r` (읽기), `w` (쓰기), `x` (실행) 권한을
 나타낸다. 파일 퍼미션은 이 세 가지 독립된 권한의 합집합으로 다음
 테이블과 같다.

| 비트 (8진수) | `ls -l` 하면 나오는 표기 | 접근 권한 뜻 |
| --- | --- | --- |
| `0o100` | `--x------` | 소유 유저가 실행 가능 |
| `0o200` | `-w-------` | 소유 유저가 쓰기 가능 |
| `0o400` | `r--------` | 소유 유저가 읽기 가능 |
| `0o10` | `-----x---` | 소유 그룹의 멤버가 실행 가능 |
| `0o20` | `----w----` | 소유 그룹의 멤버가 쓰기 가능 |
| `0o40` | `---r-----` | 소유 그룹의 멤버가 읽기 가능 |
| `0o1` | `--------x` | 다른 유저가 실행 가능 |
| `0o2` | `-------w-` | 다른 유저가 쓰기 가능 |
| `0o4` | `------r--` | 다른 유저가 읽기 가능 |
| `0o1000` | `--------t` | 끈적이 비트, `t` 비트를 그룹에 |
| `0o2000` | `-----s---` | `set-gid`, `s` 비트를 그룹에 |
| `0o4000` | `--s------` | `set-uid`, `s` 비트를 유저에게 |


 파일의 읽기, 쓰기, 실행 권한은 자명하다. 디렉토리의 경우, 실행 권한은
 그 디렉토리에 들어갈 권한 (`chdir`) 을 뜻하고, 읽기 권한은 디렉토리의
 내용물을 리스트 (`ls`) 하는 권한을 뜻한다. 하지만 디렉토리 안의
 파일이나 서브 디렉토리를 읽기 위해서 읽기 권한이 필요하진 않다 (그
 파일과 서브 디렉토리의 이름을 정확히 알고 있다면).

 좀더 정확히 말하면, 디렉토리에 실행 권한이 없으면 그 디렉토리 안의
 내용물에 대해서 아무것도 할 수 없다. 읽기 권한이 있고 그 디렉토리
 안의 특정 파일 이름을 정확히 알더라도, 실행 권한이 없으면 그 파일
 내용물을 읽을 수 없다.

 스페셜 비트는 `x` 비트가 켜지기 전까지는 의미가 없다. 즉, `x` 없이
 켜져 있으면 추가적인 권한을 갖진 않는다. 이게 바로 스페셜 비트가 `x`
 비트를 덮어쓰도록 표현되며 `x`가 안켜져 있을 때 `s`나 `t` 대신 `S`와
 `T`를 쓰는 이유이다. `t` 비트는 서브 디렉토리가 부모 디렉토리의
 권한을 물려받도록 해준다. 디렉토리에서 `s` 비트는 유저가 디렉토리를
 생성할 때 유저의 아이디가 아니라 그 디렉토리의 `uid`나 `gid`를 사용할
 수 있게 해준다. 실행 파일의 경우, `s` 비트는 실행 시간에 사용자의
 effective 아이디나 그룹을 시스템 콜 `setuid`나 `setgid`로 바꿀 수 있게
 해준다.

``` ocaml
val setuid : int -> unit
val setgid : int -> unit
```


 프로세스는, `setuid`와 `setgid`가 effective한 원래 사용자와 그룹의
 아이디를 바꿀 때, 수퍼 유저 특권이 없으면 원래 정보를
 유지한다. 프로세스가 나중에 추가적인 특권 없이도 원래의 effective
 아이디를 복구하도록 하기 위해서 원래 아이디를 유지한다. 시스템 콜
 `getuid`와 `getgid`는 원래 아이디를 돌려주고 `geteuid`와 `getegid`는
 effective 아이디를 돌려준다.

``` ocaml
val getuid : unit -> int
val getgid : unit -> int
val geteuid : unit -> int
val getegid : unit -> int
```

 프로세스는 파일 퍼미션과 같은 방식으로 인코딩된 파일 생성 마스크를
 갖는다. 그 이름이 뜻하듯이, 마스크는 금지 (삭제할 권한) 를 명세한다:
 파일이 생성되는 동안 마스크에는 비트 1로 켜지고 생성될 파일의
 퍼미션에는 비트 0으로 꺼진다. 마스크는 시스템 콜 `umask` 로 조작할 수
 있다.

``` ocaml
val umask : int -> int
```

 시스템 변수를 건드리는 다른 시스템 콜과 마찬가지로 이 함수는 그 변수
 (마스크)의 옛날 값을 돌려준다. 그래서 그냥 값만 살펴볼려면 이 함수를
 두 번 불러야 한다. 한번은 임의의 값으로 불러서 이전 값을 꺼내고 다시
 이 값으로 한번 더 불러서 복구해줘야 하는 것이다. 예를 들면 다음과
 같이 하면 된다.

``` ocaml
let get_mask () =
  let m = Unix.umask 0 in
  ignore (Unix.umask m) ;
  m
```

 파일 접근 권한은 시스템 콜 `chmod`과 `fchmod`로 건드릴 수 있다.

``` ocaml
val chmod : string -> file_perm -> unit
val fchmod : file_descr -> file_perm -> unit
```

 그리고 이 값들은 시스템 콜 `access`를 이용해 "동적으로" 확인할 수
 있다.

``` ocaml
type access_permission = R_OK | W_OK | X_OK | F_OK
val access : string -> access_permission list -> unit
```

 파일에 요청할 접근 권한을 `access_permission` 타입의 리스트에 담아서
 보내면 된다. `F_OK`는 다른 퍼미션 확인 없이 파일이 존재하는지 여부만
 확인한다. 만약 요청한 권한이 허락되지 않으면 예외를 일으킨다.
