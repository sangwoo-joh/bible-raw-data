# Unix System Programming in OCaml

## 1. Generalities
### 1.1. Modules `Sys` and `Unix`
 `Sys`에는 유닉스나 다른 운영체제에 공통 인터페이스가 담겨 있고
 `Unix`는 유닉스 특화 인터페이스가 담겨 있다.

 각 모듈은 기존의 `Pervasives` 모듈의 식별자를 재정의 하기도
 한다. 예를 들면 `Pervasives.stdin` 이랑 `Unix.stdin`은 다른 타입이다.

### 1.2. Interface with the calling program
 쉘에서 프로그램을 실행하면, 쉘은 *아규먼트*와 *환경*을 프로그램에게
 전달해준다. 아규먼트는 커맨드 라인에서 방금 실행한 프로그램의 커맨드
 이후의 모든 단어들이다. 환경은 `variable=value` 형식을 가진 문자열의
 집합으로, 환경 변수의 글로벌 바인딩을 나타낸다. `csh`에서는 `setenv
 var=val` 으로, `sh` 에서는 `var=val; export var`로 가능하다.

#### `var argv: string array`
 아규먼트는 `Sys.argv`에 문자열 배열로 전달된다.

#### `val environment : unit -> string array`
 프로그램의 환경은 `Unix.environment` 함수로 얻을 수 있다.

#### `val getenv : string -> string`
 환경 변수를 얻는 좀더 편한 방법으로는 `Sys.getenv`가
 있다. `Sys.getenv v`는 변수 `v` 에 연결된 환경 변수 값을 돌려주는데,
 바인딩이 없으면 `Not_found` 예외를 던진다.

 예시는 프로그램의 아규먼트를 출력하는 [에코
 프로그램](sample/ex_1.2_echo.ml)이다.

#### `val exit : int -> 'a`
 인자 `int`는 프로그램을 호출한 프로그램에게 돌려주는 리턴 코드
 값이다. 관습적으로 `0`은 모든 게 잘 됐다는 걸 뜻하고, 그 외의 `0`이
 아닌 코드는 오류라는 신호이다. 조건문에서 `sh` 쉘은 리턴 코드 `0`을
 불리언 값 "True"로 해석하고, 모든 `0`이 아닌 값을 불리언 값 "False"로
 해석한다. 어떤 프로그램이 담고 있는 모든 표현식을 정상적으로 실행하고
 종료한다면, 암묵적으로 `exit 0`을 호출한다. 어떤 프로그램이 중간에
 어떤 예외가 발생했지만 그것을 놓친 채로 종료되면, 암묵적으로 `exit
 2`를 호출한다. `exit` 함수는 항상 (쓰기 위해 열려 있는) 모든 채널의
 버퍼를 비운다 (flush). `at_exit` 함수는 프로그램이 종료할 때 수행할
 다른 동작을 예약 등록할 수 있다.

#### `val at_exit : (unit -> unit) -> unit`
 마지막에 등록한 함수부터 호출된다. 즉, 스택이다. `at_exit`로 등록한
 함수는 등록해제할 수 없다.

### 1.3. Error handling
 특별한 일이 없으면, `Unix` 모듈의 모든 함수는 오류 시에
 `Unix_error`를 던진다.

#### `exception Unix_error of error * string * string`
 두번째 아규먼트는 이 오류를 던진 시스템 콜의 이름이다. 세번째
 아규먼트는 (가능한 경우에만) 오류가 발생한 오브젝트이다. 예를 들어서,
 파일 이름을 아규먼트로 받는 시스템 콜의 경우, 이 파일 이름이 세번째
 아규먼트에 담긴다. 마지막으로 첫번째 아규먼트는 에러 코드로 오류의
 성질을 나타낸다.

#### `type error = E2BIG | EACCES | EAGAIN | ... | EUNKNOWNERR of int`
 이 타입 생성자는 POSIX 표준과 UNIX98, BSD의 오류에 쓰인 이름과 의미를
 따른다. 이외의 모든 오류는 `EUNKOWNERR` 생성자를 쓴다.

 예외의 시맨틱에 따라, 명확하게 예측하지 못해서 `try` 를 이용해
 다뤄지지 않은 오류는 프로그램의 최상단까지 전파되어서 프로그램을
 이르게 종료시켜버린다. 작은 어플리케이션에서는 예측 못한 오류를
 치명적인 오류로 다루는건 좋은 방법이다. 하지만, 에러를 분명하게
 드러내는게 좋다. 이를 위해서 `Unix` 모듈은 아래 함수를 제공한다.

#### `val handle_unix_error : ('a -> 'b) -> 'a -> 'b`
 `handle_unix_error f x`는 함수 `f`를 아규먼트 `x`로 호출한다. 만약
 이게 `Unix_error` 예외를 일으키면, 그 오류를 설명하는 메시지를
 출력하고 프로그램은 `exit 2`로 종료된다. 전형적인 사용법은
 `handle_unix_error prog () ;;` 처럼 `prog : unit -> unit` 함수가
 프로그램의 본체를 실행하는 경우이다. `handle_unix_error` 함수는
 [이렇게](sample/ex_1.3_unix_error.ml) 구현할 수 있다. `prerr_xxx` 류
 함수는 `print_xxx` 함수랑 똑같이 동작하는데 대신 표준출력인
 `stdout`이 아니라 표준오류인 `stderr`에 쓴다.

#### `val error_message : error -> string`
 주어진 오류를 설명하는 메시지를 돌려준다.


### 1.4. Library functions
 시스템 프로그래밍에서는 종종 같은 패턴이 반복된다. 이런 코드를
 본질적으로 줄이기 위해서, 보통은 공통 부분을 빼서 라이브러리로
 만든다.

 완전한 프로그램에서는 어떤 오류가 발생할지 정확하게 아는 반면, 보통
 라이브러리 함수의 경우는 실행 문맥을 제대로 알지 못한다. 그렇다고
 모든 오류가 치명적이라고 가정할 수도 없다. 그러므로 에러가 다시 (그
 에러를 일으킨) 호출자에게 돌아가서, 적절한 행동 방침에 따르는 것이
 좋다. 하지만, 라이브러리 함수는 시스템의 일관된 상태를 유지하기
 위해서, 오류가 그 라이브러리 함수를 빠져나가서 다른 함수로 전달되는게
 보통은 허락되지 않는다. 예를 들어서, 파일을 열어서 그 파일
 디스크립터에게 함수를 적용하는 라이브러리 함수는 모든 경우에 그 파일
 디스크립터를 닫는 일에 신경써야 하는데, 파일에 쓰다가 오류가 나는
 경우도 마찬가지다. 그러지않으면 파일 디스크립터 누수가 발생할 수
 있고, 파일 디스크립터가 고갈될 수 있다.

 게다가, 파일에 적용된 연산은 다른 함수에서 정의될 수도 있는데, 이
 경우 언제 또는 어떻게 실패할지 정확하게 알 수 없다. 그러므로 종종
 "마무리짓는" 코드를 이용해서 작업의 본체를 보호한다. 보통 이런
 "마무리"는 함수가 정상 실행하든 실패하든 리턴하기 직전에 호출되어야
 한다.

 아쉽게도 OCaml은 내장 마무리 문법이 없지만, 다음처럼 쉽게 정의할 순
 있다:

``` ocaml
let try_finalize f x finally y =
  let res = try f x with exn -> finally y; raise exn in
  finally y;
  res
```

## 2. Files
 "파일" 이라는 단어는 여러 타입의 오브젝트를 다룬다:

 * 표준 파일: 텍스트나 바이너리 정보를 담고 있는 바이트의 유한 집합,
   종종 "일반" 파일로 부름.
 * 디렉토리
 * 심볼릭 링크
 * 특수한 파일 (장치): 주로 컴퓨터 주변기기에 접근을 제공함.
 * 이름있는 파이프
 * Unix 도메인에서의 이름있는 소켓


 파일의 컨셉은 파일에 담긴 데이터와 파일의 타입, 접근 권한, 마지막
 수정 시간과 같은 파일 그 자체의 정보 (메타 데이터) 를 모두 포함한다.


### 2.1. The file system
 엄청 요약하면 파일 시스템은 트리로 생각할 수 있다. 루트는 `/` 이고,
 브랜치는 `\000`과 `/`를 제외한 (파일) 이름으로 표현된다 (출력할 수
 없는 문자와 공백을 파일 이름에 쓰지 않는 것은 좋은
 실천이다). 논터미널 노드는 *디렉토리*이다: 이런 노드는 항상 두 개의
 브랜치 `.`과 `..`을 갖고 있는데 각각 그 디렉토리 자체와 그 디렉토리의
 부모를 가리킨다. 다른 노드는 *파일*이라고 부르는데, 이건 좀
 모호하다. 왜냐하면 다른 모든 노드 또한 "파일"이라고 부를 수 있기
 때문에. 그래서 보통은 *논디렉토리 파일 (non-directory files)* 이라고
 부른다.

 트리의 노드는 경로를 통해 다뤄진다. 어떤 경로가 루트로 시작하면 *절대
 경로*라고 하고, 어떤 디렉토리로 시작하면 *상대 경로*라고 한다. 즉,
 *상대 경로*는 경로가 `/` 문자로 구분되는 이름이며, *절대 경로*는
 `/`로 시작하는 상대 경로이다. `/`가 경로 구분자로도 쓰이지만 루트를
 뜻하는데도 쓰이는 것을 주의하자.

 `Filename` 모듈은 포터블한 경로를 다룬다. 예를 들어서, `concat`
 함수는 `/` 문자를 지정하지 않아도 경로를 합치는데, 다른 운영체제
 (예를 들어 윈도우즈에서는 경로 구분자가 `\`이다) 에서도 동일한 동작을
 하도록 해준다. `Filename` 모듈은 문자열 값 `current_dir_name`과
 `parent_dir_name`을 제공하는데 이는 트리에서 `.`과 `..`와
 같다. `basename`과 `dirname` 함수는 경로 `p`가 `d/b`가 같은 파일을
 가리키고 `d`가 그 파일이 있는 디렉토리이고 `b`가 파일일 때, 접두사
 `d`와 접미사 `b`를 돌려준다. `Filename` 모듈의 함수는 오직 경로에
 대해서만 동작한다.

 사실 엄밀히 말하면 파일 계층은 트리가 아니다. 먼저 디렉토리 `.` 는
 디렉토리가 스스로를 가리키도록 해주고, `..`는 어떤 디렉토리에서
 이어지는 경로를 정의하기 위해서 디렉토리 계층에서 하나 위로 이동할 수
 있도록 해준다. 게다가, 논디렉토리 파일은 여러 개의 부모 (*하드 링크*)
 를 가질 수 있다. 마지막으로, *심볼릭 링크*가 있는데 경로를 담은
 논디렉토리 파일이다. 이때 개념적으로는 일반 파일처럼 심볼릭 링크의
 내용을 읽어서 이 경로를 얻을 수 있다. 심볼릭 링크가 경로 중간에
 나타날때마다 그 경로를 투명하게 따라가야 한다. 만약 `s`가 심볼릭
 링크이고 값이 경로 `l` 이면, 경로 `p/s/q`는 (1) `l`이 절대 경로이면
 파일 `l/q`를, (2) `l`이 상대 경로이면 파일 `p/l/q`를 나타낸다.

 보통 파일 계층의 재귀적 탐색은 다음 규칙을 잘 준수하면 끝난다:

  * 디렉토리 `.`과 `..`를 무시한다.
  * 심볼릭 링크를 따라가지 않는다.

 하지만 만약 심볼릭 링크를 따라가면 그래프를 탐색하게 되는데, 이때
 무한루프에 빠지는 것을 막기 위해서는 방문한 노드를 기록해야 한다.

 각각의 프로세스는 현재 작업 디렉토리를 갖고 있다. `getcwd` 함수로
 이걸 확인할 수 있고, `chdir` 함수로 이걸 바꿀 수 있다. 또한 `chroot`
 함수로 파일 계층의 뷰를 제한할 수 있다. `chroot p`를 호출하면 `p`
 (디렉토리여야 한다) 를 새로운 제한된 파일 계층 뷰의 루트로
 지정한다. 그러면 절대 경로는 이 새로운 루트 `p`에 의해
 재해석된다. 당연히 `p` 에서의 `..` 는 `p` 자신이다.


### 2.2. File names and file descriptors
 파일에 접근하는데는 두 가지 방법이 있다. 하나는 파일 계층의 *파일
 이름* 또는 *경로 이름*으로 접근하는 것이다. 하드 링크 탓에, 한 파일은
 여러 개의 이름을 가질 수 있다. 이름은 `string` 타입이다. 예를 들면
 다음 함수들은 파일 이름 레벨에서 동작한다.

 * `val unlink : string -> unit` : `unlink f` 는 `rm -f f`
 * `val link : string -> string -> unit` : `link f1 f2` 는 `ln f1 f2`
   (하드 링크)
 * `val symlink : string -> string -> unit` : `symlink f1 f2` 는 `ln
   -s f1 f2` (심볼릭 링크)
 * `val rename : string -> string -> unit` : `rename f1 f2` 는 `mv f1
   f2`

 파일에 접근하는 두 번째 방법은 파일 디스크립터를 통한 접근이다. 한
 디스크립터는 한 파일을 가리키는 포인터를 나타내고, 추가적으로
 파일에서의 현재 읽기/쓰기 위치, 접근 권한, 읽기/쓰기 행동을 제한하는
 플래그 등의 다른 정보를 갖고 있다. 파일 디스크립터는 추상 타입
 `file_descr` 이다.

 디스크립터를 통한 파일 접근은 이름으로 접근하는 것과는
 독립적이다. 구체적으로 파일 디스크립터를 얻을 때마다, 그 파일은
 삭제되거나 이름이 바뀔 수 있는데, 디스크립터는 여전히 그 파일을
 가리킬 것이다.

 프로그램이 실행되면, 세 개의 디스크립터가 할당되고 각각 `Unix` 모듈의
 `stdin`, `stdout`, `stderr` 변수에 묶인다:

 * `val stdin : file_descr`
 * `val stdout : file_descr`
 * `val stderr : file_descr`

  각각 그 프로세스의 표준입력, 표준출력, 표준오류에 해당한다.

  프로그램이 리다이렉션 없이 커맨드라인으로 실행될 때, 이 세 개의
  디스크립터는 모두 터미널을 가리킨다. 하지만 만약, 예를 들어서 입력이
  `cmd < f` 쉘 표현식 등을 통해 리다이렉션된 경우, `stdin`
  디스크립터는 `cmd` 커맨드가 실행되는 동안 파일 `f`를
  가리킨다. 비슷하게, `cmd > f` 와 `cmd 2> f` 는 각각 `stdout`과
  `stderr`가 파일 `f`를 가리키도록 한다.
