# Inter-process communications

## 1. Pipes

 일반 파일은 병렬로 실행되는 프로세스에게 만족스러운 커뮤니케이션
 수단이 아니다. 예를 들면 여러 명의 읽는 애랑 한 명의 쓰는 애가 있는
 상황을 생각해봐라. 어떤 파일 하나가 커뮤니케이션 수단으로 사용된다고
 하면, 읽는 애는 어느 순간 파일이 더 이상 자라지 않는 걸 깨닫게 되는데
 (즉, `read`가 0을 리턴한다), 이때 얘는 쓰는 애가 쓰는걸 다 끝냈는지
 아니면 단순히 쓰기 위한 데이터를 계산하느라 바쁜지 알 수가
 없다. 게다가, 파일에는 이때까지 전송한 모든 데이터가 다 들어있어서,
 쓸데없는 디스크 공간도 차지한다.

 *파이프*는 이런 종류의 커뮤니케이션에 알맞는 메커니즘을
 제공한다. 파이프 하나는 두 개의 파일 디스크립터로 구성된다. 하나는
 파이프의 출력이고, 다른 하나는 파이프의 입력이다. 파이프는 시스템 콜
 `pipe`로 만든다.

```ocaml
val pipe : unit -> file_descr * file_descr
```

 이걸 호출하면 `(fd_in, fd_out)` 쌍을 얻을 수 있는데, `fd_in`은
 파이프의 출력에 대해서 *읽기 모드*로 열린 파일 디스크립터이고,
 `fd_out`은 파이프의 입력에 대해서 *쓰기 모드*로 열린 파일
 디스크립터이다. 파이프 그 자체는 커널의 내부 오브젝트로 이렇게 생성한
 두 개의 파일 디스크립터로만 접근할 수 있다. 그리고 파일 시스템 상에서
 이름을 갖지 않는다.

 `fd_out` 디스크립터에 데이터를 써서 파이프를 채우고, 파이프에 채워진
 데이터는 `fd_in` 디스크립터를 통해 읽어내는 구조다.

 파이프는 큐다. 제일 처음 쓰여진 데이터가 제일 처음 읽힌다. `write`
 함수를 파이프의 입력 디스크립터 (`fd_out`)에 호출하여 쓰는 일은
 파이프에 데이터를 채우거나 파이프가 꽉찬 경우 블럭된다. 이때 다른
 프로세스가 이 파이프에서 (`fd_in` 으로부터) 데이터를 충분히 읽어서
 `write` 하려던 데이터 크기만큼 파이프가 비워질 때까지
 블럭된다. `read`를 파이프의 출력 디스크립터 (`fd_in`)에 호출하여 읽는
 일은 파이프에서 데이터를 빼낸다. 파이프가 비어있으면, `read` 호출은
 최소 한 바이트가 채워질때까지 블럭된다. 그런 다음 `read` 호출로
 읽어들이려던 바이트 수만큼이 채워질 때까지 기다리지 않고 즉시
 리턴한다.

 같은 프로세스에서 쓰고 읽는 경우 파이프는 쓸모없다. 그런 프로세스는
 엄청난 크기의 쓰기 작업이나 빈 파이프에서 읽는 작업으로 영원히 블럭될
 가능성이 높다. 그래서 보통은 서로 다른 프로세스끼리 읽고 쓰는 일에
 쓰인다. 파이프는 이름이 없기 때문에, 이런 프로세스는 반드시 파이프를
 만든 프로세스에서 fork 해야 된다. 실제로, 파이프의 두 개의 파일
 디스크립터는, 다른 파일 디스크립터와 마찬가지로, `fork` 호출 시에
 복제되고 이로 인해 자식과 부모 프로세스가 같은 파이프를 참조할 수
 있는 것이다.

```ocaml
let (fd_in, fd_out) = Unix.pipe () in
match fork () with
| 0 -> close fd_in; ... write fd_out buffer1 offset1 count1 ...
| pid -> close fd_out; ... read fd_in buffer2 offset2 count2 ...
```

 `fork` 하고나면 파이프의 입출력에 대해서 파일 디스크립터가 각각 두
 개씩 열리게 된다. 위의 코드에서는 자식이 쓰는 애가 되고 부모가 읽는
 애가 된다. 따라서 자식은 `fd_in` 디스크립터를 닫아서 파이프의
 출력으로부터 읽지 않도록 하고, 부모는 `fd_out` 디스크립터를 닫아서
 파이프의 입력에다 쓰지 않도록 한다. 이를 통해 부모와 자식의 메모리를
 서로소로 만든다 (Disjoint). 이는 파일 디스크립터도 정리하고,
 프로그래밍 실수도 방지하는 방법이다. 결과적으로는 다음과 같이 된다.


 `fd_out` (child) (input) -> PIPE -> `fd_in` (parent) (output)


 자식이 `fd_out`에 데이터를 쓰면 부모가 `fd_in`에서 데이터를 읽을 수
 있다.


 파이프의 입력에 대한 모든 디스크립터가 닫혀 있고 파이프가 비어있으면,
 파이프의 출력에 `read`를 호출하면 0을 리턴하여 파일의 끝을 알린다
 (EOF). 파이프의 출력에 대한 모든 디스크립터가 닫혀 있으면, 파이프의
 입력에 `write`를 호출하면 쓰는 작업을 죽여버린다. 더 정확히는, 커널이
 `write`를 호출 중인 프로세스에 `sigpipe` 시그널을 보내서 이 시그널의
 디폴트 핸들러가 프로세스를 죽여버린다. 만약 `sigpipe` 시그널 핸들러가
 바뀌면, `write` 호출은 `EPIPE` 에러로 종료된다.

## 2. Complete example

 - [parallel sieve of Eratosthenes](sample/ex_5.2_pipe.ml)

## 3. Named pipes
 System V, SunOS, Ultrix, Linux, BSD같은 유닉스 시스템에서는 파일
 시스템 상에서 이름을 갖는 파이프를 만들 수 있다. 이런 *이름있는
 파이프*는 *fifo*라고도 불리는데, 부모/자식 관계가 아니더라도
 프로세스끼리 커뮤니케이션을 하도록 해준다. 일반적인 파이프랑은
 다르다.

```ocaml
val mkfifo : string -> file_perm -> unit
```

 `mkfifo` 시스템 콜이 이름있는 파이프를 만들어준다. 첫번째 아규먼트는
 파이프의 이름이고, 두번째는 요청할 접근 권한이다.

 이름있는 파이프는 아무 일반 파일에 `openfile`을 호출한 것처럼
 열린다. 이름있는 파이프에서 읽고 쓰는 일은 일반 파일에서 읽고 쓰는
 일과 동일한 시맨틱을 갖는다. 읽기 전용 모드로 이름있는 파이프를 열면
 그 파이프가 다른 프로세스에 의해 쓰기 전용 모드로 열릴 때까지
 블럭된다. 쓰기 전용 모드로 열린 경우는 반대로 읽기 전용 모드로 열릴
 때까지 블럭된다. 이미 열려있는 경우는 블럭 안된다. `O_NONBLOCK`
 플래그를 줘서 블럭 없이 열 순 있지만, 이 경우 파이프에서 읽고 쓰는 일
 역시 블럭 안된다. 파이프가 열리고 나면, `clear_nonblock` 함수는 이
 플래그를 바꿔서 읽고 쓰는 일이 블럭되게 만든다. 반면, `set_nonblock`
 함수는 읽고 쓰는 일을 블럭 안되게 만든다.

```ocaml
val clear_nonblock : file_descr -> unit
val set_nonblock : file_descr -> unit
```

## 4. Descriptor redirections
 프로세스의 표준입력과 표준출력을 파이프랑 어떻게 연결하는지 여전히
 모른다. 쉘에서는 `cmd1 | cmd2` 와 같이 명령어를 실행하면
 연결되는데. 실제로, `pipe`로 얻은 파이프 또는 이름있는 파이프에
 `openfile`로 얻은 디스크립터는 *새로운* 디스크립터이고, `stdin`,
 `stdout`, `stderr`과는 구분된다.

 이 문제를 다루기 위해서, 유닉스는 `dup2` 시스템 콜 ("*dup*licate a
 descriptor *to* another descriptor" 로 읽는다) 을 제공한다. 이 함수는
 하나의 파일 디스크립터를 다른 디스크립터랑 같은 의미를 갖게
 해준다. 이게 가능한 이유는 파일 디스크립터 (`file_descr` 타입) 와
 실제 파일 또는 파이프를 가리키고 현재까지 읽고 쓴 위치를 기록해주는
 커널의 오브젝트인 *파일 테이블 엔트리* 사이에 간접적인 단계가 있는
 덕분이다.


```ocaml
val dup2 : file_descr -> file_descr -> unit
```

 `dup2 fd1 fd2` 를 통해 디스크립터 `fd2` 를 `fd1`이 가리키는 파일
 테이블 엔트리를 참조하도록 업데이트 할 수 있다. 이러고나면, 이 두
 개의 파일 디스크립터는 같은 파일 또는 파이프에 대해서 같은 읽기/쓰기
 위치를 참조하게 된다.


### Standard input redirection

```ocaml
let fd = openfile "foo" [O_RDONLY] 0 in
dup2 fd stdin;
close fd;
execvp "bar" [|"bar"|]
```

 위 코드에서 `dup2`를 호출하고 나면 `stdin`가 파일 `foo`를 가리키게
 된다. 따라서 `stdin`에서 읽는 모든 데이터는 파일 `foo`를 읽는 것과
 같다. 이는 `fd`를 읽는 것도 마찬가지지만, 여기서는 더 이상 쓰지 않기
 때문에 `fd`를 닫았다. 이 설정은 `execvp`를 호출할 때도 유지되기
 때문에 `bar` 프로그램을 실행하면 표준입력이 파일 `foo`에
 연결된다. 이게 바로 쉘에서 `bar < foo` 명령어를 실행하면 일어나는
 일이다.

### Standard output redirection

```ocaml
let fd = openfile "foo" [O_WRONLY; O_TRUNC; O_CREAT] 0o666 in
dup2 fd stdout;
close fd;
execvp "bar" [|"bar"|]
```

 위 코드에서는 `dup2`를 호출하고 나면 `stdout`이 파일 `foo`를 가리키게
 된다. 역시 `fd`도 마찬가지지만 안쓰니까 닫았다. 이 설정은 역시
 `execvp`를 호출할 때에도 유지되기 때문에 `bar` 프로그램이 실행되면서
 표준출력에 출력되는 내용은 파일 `foo`에 연결되어 거기에 써진다. 이게
 바로 쉘에서 `bar > foo` 명령어를 실행하면 일어나는 일이다.


### Connecting the output of a program to the input of another

```ocaml
let (fd_in, fd_out) = pipe () in
match fork () with
| 0 ->
  dup2 fd_in stdin;
  close fd_out;
  close fd_in;
  execvp "cmd2" [|"cmd2"|]
| _ ->
  dup2 fd_out stdout;
  close fd_out;
  close fd_in;
  execvp "cmd1" [|"cmd1"|]
```

 여기서는 프로그램 `cmd2`가 실행될 때 표준입력이 파이프의
 출력(`fd_in`)과 연결되었다. 병렬적으로, 프로그램 `cmd1`이 실행될 때는
 표준출력이 파이프의 입력(`fd_out`)과 연결되었다. 따라서 `cmd1`이
 표준출력에 뭘 출력하던 간에 `cmd2` 가 표준입력에서 이를 읽게
 된다. (`cmd1` -> `cmd2`)

 여기서 `cmd2`가 끝나기 전에 `cmd1`이 끝나면 어떻게 될까? `cmd1`이
 끝날 때, 그 프로세스가 열어둔 모든 디스크립터는 닫힌다. 이 말은
 파이프의 입력에 대해서 열린 디스크립터가 모두 닫힌다는
 뜻이다. `cmd2`가 파이프에서 기다리고 있는 모든 데이터를 읽었을 때, 그
 다음 읽기는 파일의 끝을 리턴할 것이다; 그러고나면 `cmd2`는 표준입력의
 끝에 도달했을 때 해야 할 일을 하게 된다. 예를 들면, 종료한다.

 이번엔 반대로 `cmd1`이 끝나기 전에 `cmd2`가 끝나는 경우를
 생각해보자. 이때는 파이프의 출력에 대한 마지막 디스크립터가 닫히게
 되고, 표준출력에 쓸려고 할 때 `cmd1`은 시그널 (프로세스를 죽이는) 을
 받게 된다.


 디스크립터를 서로 바꾸는 일은 주의를 요한다. 순진하게 `dup2 fd1 fd2;
 dup2 fd2 fd1`은 당연히 동작안한다. 이 경우 두번째 리다이렉션은 아무런
 효과가 없는데, 첫번째에서 `fd1`과 `fd2`가 이미 같은 파일 테이블
 엔트리를 가리키기 때문이다. 이로 인해 `fd2`가 가리키던 값은
 잃어버린다. 두 값을 서로 바꿀때는 당연히 중간에 임시 변수가
 필요하다.

```ocaml
val dup : file_descr -> file_descr
```

 `dup fd`를 호출하면 `fd`와 같은 파일 테이블 엔트리를 가리키는 새로운
 디스크립터를 돌려준다. 이걸가지고 다음처럼 `stdout`과 `stderr`을
 스왑할 수 있다.

```ocaml
let tmp = dup stdout in
dup2 stderr stdout;
dup2 tmp stderr;
close tmp
```

 여기서 마지막에 다 쓰고 난 임시 디스크립터를 닫는 것을 잊지말자!


## 5. Complete example : composing N commands

 - [composing N commands](sample/ex_5.5_compose.ml)


## 6. Input/output multiplexing

 이때까지 본 예제에서는 프로세스끼리 *선형적으로*
 커뮤니케이션했다. 즉, 각각의 프로세스는 최대 하나의 프로세스에서
 데이터를 읽어들였다. 여기서는 *많은* 프로세스에서 데이터를 읽을 때
 어떤 문제가 발생하는지와 이걸 어떻게 해결할지 고민해보자.

 멀티 윈도우 터미널 에뮬레이터를 생각해보자. 클라이언트가 있고 이게
 유닉스 머신의 시리얼 포트에 연결되어 있다. 이 클라이언트에서 유닉스
 머신의 서로 다른 유저 프로세스에 연결해서 다수의 터미널 윈도우를
 에뮬레이트 한다고 하자. 예를 들면, 한 윈도우는 쉘에 연결되고, 다른
 윈도우에서는 텍스트 에디터에 연결된다. 쉘의 출력은 첫번째 윈도우에
 뿌려지고, 텍스트 에디터의 출력은 다른 윈도우에 뿌려진다. 만약 첫번째
 윈도우가 활성화 상태라면, 클라이언트의 키 입력은 쉘의 입력에
 전달되고, 두번째 윈도우가 활성화 상태라면 에디터에 전달된다.

 클라이언트와 유닉스 머신 사이에는 단 하나의 물리적 링크만 있기
 때문에, 데이터 전송을 중간 중간에 끼워 넣어서 (interleaving) 윈도우와
 프로세스 사이의 가상 연결을 *다중화 (multiplex)* 해야
 한다. 프로토콜은 다음과 같다. 시리얼 포트에서는 다음과 같은 구조로
 메시지를 보낸다.

 - 1 바이트는 수신측의 프로세스 번호 또는 윈도우 번호를 나타낸다.
 - 1 바이트는 이후에 따라오는 `N` 바이트의 데이터 크기를 나타낸다.
 - `N` 바이트의 데이터가 수신측에 전송된다.

 유닉스 머신에서는, 유저 프로세스 (쉘, 에디터 등) 들이 파이프를 통해
 하나 또는 그 이상의 보조 프로세스에 연결되어서 시리얼 포트에서
 데이터를 읽거나 쓰고 그 데이터를 다중화하거나 역다중화 (demultiplex)
 한다. 시리얼 포트는 `/dev/ttya` 와 같은 특수 파일로, 보조 프로세스가
 `read`와 `write` 시스템 콜을 호출하여 클라이언트와 통신하는 곳이다.

 역다중화 (클라이언트에서 유저 프로세스로 전송) 는 특별히 문제가
 없다. 시리얼 포트에서 메시지를 읽어서 수신측 유저 프로세스의
 표준입력에 연결된 파이프에 그 추출한 데이터를 쓰는 프로세스만 있으면
 된다.

```shell
                                 +---------> shell
/dev/ttya ----> demultiplexer ---|
                                 +---------> emacs
```

 다중화 (유저 프로세스에서 클라이언트로 전송) 은 좀더 까다롭다. 먼저
 역다중화를 흉내내보자: 한 프로세스가 유저 프로세스의 표준출력에
 연결된 파이프에서 데이터를 순차적으로 읽어서 그 데이터에 윈도우
 번호와 데이터 길이를 추가해서 메시지로 만든 다음 이걸 시리얼 포트에
 쓴다고 해보자.

```shell
 ... ----> shell ------+
                       |----> multiplexer -------> /dev/ttya
 ... ----> emacs ------+
```

 이건 동작 안한다. 왜냐하면, 파이프에서 읽어 들이는게 블록될 수
 있다. 예를 들어서, 쉘의 출력을 읽으려고 하는데 그 순간에는 당장
 보여줄 게 없으면, 다중화 프로세스가 블록되어서, 에디터에서 문자열을
 기다리는 일이 무시된다. 보여줄 데이터가 어떤 파이프에서 기다리고
 있는지 미리 알 수 있는 방법은 없다. 병렬 알고리즘에서는, 프로세스가
 공유 자원에 접근하는 일이 영원히 거부되는 것을 *기아 상태
 (starvation)* 라고 한다.

 그럼 이런 접근은 어떨까? 각각의 유저 프로세스를 *리피터* 프로세스에
 연결하는 거다. 리피터는 유저 프로세스의 표준출력에 연결된 파이프의
 데이터를 읽어서, 데이터를 메시지로 바꾸고, 그 결과를 시리얼
 포트에다가 곧바로 쓴다. 각각의 리피터 프로세스는 `/dev/ttya` 를 쓰기
 모드로 연다.

```shell
 ... ----> shell ------> repeater --------+
                                          |------->> /dev/ttya
 ... ----> emacs ------> repeater --------+
```

 이제 각각의 프로세스가 그 출력을 독립적으로 전송할 수 있게 되었으니,
 블록되는 문제는 없다. 하지만, 프로토콜이 지켜지지 않을 수 있다. 두
 개의 리피터가 동시에 메시지를 쓰려고 하면 유닉스 커널이 이 쓰기
 작업들의 원자성을 보장하지 않는다. 그래서, 커널은 `/dev/ttya`에 한
 리피터의 메시지 일부를 먼저 쓰고, 다른 리피터의 메시지 전체를 쓴
 다음, 마지막으로 첫번째 메시지의 나머지 부분을 쓸 수 있다. 이렇게되면
 클라이언트에서 역다중화 할 때 완전히 헷갈린다: 두 번째 메시지를 마치
 첫 번째 메시지의 데이터로 해석하게 되고, 나머지 부분을 다른 메시지의
 헤더로 해석하게 된다. 엉망이다.

 이걸 피하기 위해서, 리피터 프로세스는 반드시 동기화 해서 어떤 때라도
 최대 하나의 리피터가 시리얼 포트에 쓰기 작업을 하도록 해야한다. 병렬
 알고리즘에서는 이런걸 *상호 배제 (mutual exclusion)* 이라고
 한다. 기술적으로 이건 간단하게 해결할 수 있다. 리피터는 메시지를
 보내기 전에 특별한 파일인 자물쇠를 `O_EXCL` 플래그로 만들고, 시리얼
 포트에 쓰는 작업을 다 끝내면 이걸 삭제할 수 있다. 하지만, 이 기법은
 자물쇠를 만들고 삭제하는 작업이 너무 비싸기 때문에 별로 효율적이지
 않다.

 좀더 나은 해결책은 첫번째 접근, 즉 하나의 다중화 프로세스를 가져가되,
 파이프의 출력을 유저 프로세스의 표준출력에 논블록 모드 `set_nonblock`
 으로 연결하는 것이다. 비어있는 파이프를 읽는 작업은 블록되긴 하지만
 `EAGAIN` 또는 `EWOULDBLOCK` 에러와 함께 즉시 리턴된다. 이 오류를 그냥
 무시하고 그 다음 유저 프로세스의 출력을 계속 읽도록 시도하면
 된다. 이러면 기아 상태도 방지하고 상호 배제 문제도 피할 수
 있다. 하지만, 이건 굉장히 비효율적인 해결책인데, 다중화 프로세스가
 소위 말하는 "기다리느라 바쁜 (busy waiting)" 작업을 하기 때문이다:
 즉, 데이터를 보내는 프로세스가 없어도 데이터가 있는지 확인하는데
 시간을 써버린다. 물론 읽는 시도를 하는 루프에서 `sleep` 시스템 콜을
 이용해서 완화할 순 있지만, 불행히도 이 경우 적절한 대기 시간을 찾는
 것은 굉장히 어렵다. 짧은 `sleep` 은 데이터가 별로 없을 때 불필요한
 CPU 부하를 주고, 긴 `sleep`은 데이터가 엄청 많을 때 인지할 수 있을
 정도의 딜레이를 낳는다.

 이건 매우 심각한 문제다. 이걸 해결하기 위해서, BSD 유닉스의 개발자는
 새로운 시스템 콜인 `select`를 도입했고 이제 이건 대부분의 유닉스
 시스템에서 제공한다. `select` 를 호출하면 어떤 프로세스가
 (수동적으로) 하나 또는 그 이상의 입/출력 이벤트를 기다릴 수 있도록
 해준다. 이 이벤트에는:

 - 읽기 이벤트: 디스크립터에 읽어 들일 수 있는 데이터가 있다.
 - 쓰기 이벤트: 디스크립터에 블록 없이 데이터를 쓸 수 있다.
 - 예외 이벤트: 디스크립터에 예외적인 조건이 참이 되어버렸다. 예를
   들어, 특정 네트워크 연결에서는 높은 우선순위의 데이터 (*out-of-band
   data*) 가 일반적인 데이터를 앞지를 수 있다. 이런 종류의 데이터를
   받는 일은 예외적인 조건이다.

```ocaml
val select : file_descr list -> file_descr list -> file_descr list
           -> float -> file_descr list * file_descr list * file_descr list
```

 `select`의 시그니쳐에서 첫 세 개의 아규먼트는 디스크립터
 리스트이다. 이 중 첫번째는 읽기 이벤트, 두번째는 쓰기 이벤트,
 세번째는 예외 이벤트를 감시하기 위한 디스크립터 집합이다. 네번째
 아규먼트는 초 단위의 타임아웃이다. 0 또는 양의 값이면 `select` 호출이
 이벤트가 일어나지 않았어도 그 시간만큼 이후에 리턴한다. 음의 값이면
 요청한 이벤트가 일어날 때까지 무한정 기다린다.

 `select` 호출은 최종적으로 디스크립터 리스트의 3-튜플을
 리턴한다. 역시 첫번째는 읽기, 두번째는 쓰기, 세번째는 예외에 대한
 디스크립터 집합이다. 이벤트가 일어나기 전에 타임아웃이 다 되어서
 리턴했으면 이 셋 다 비어있다.

```ocaml
match Unix.select [fd1; fd2] [] [] 0.5 with
| [], [], [] -> (* timeout 0.5s expired *)
| fdl, [], [] ->
  if List.mem fd1 fdl then (* read from fd1 *);
  if List.mem fd2 fdl then (* read from fd2 *);
  ...
```
