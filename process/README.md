# Process

## 프로세스 환경

 C 프로그램의 시작점은 `main` 함수다: `int main (int argc, char *argv[]);`

 C 프로그램이 `exec` 함수로 실행되면, start-up routine을 먼저 호출해서
 커널에서 여러가지 정보(아규먼트, 환경변수 등)를 받아서 실제로
 `main`을 구동하기 위해 필요한 걸 준비한다.

 `void exit(int status);` 함수는 모든 열린 *스트림*에 대하여
 `fclose()`를 호출한다. 이를 통해 버퍼의 모든 데이터가 flush 된다.

 커널에서 프로그램을 실행하는 유일한 방법은 `exec`류 함수를 호출하는
 것이고, 프로세스가 자발적으로 종료하는 유일한 방식은
 명시적/암묵적으로 `_exit`, `_Exit`가 호출되는 것(`exit()`)이다.

 환경변수는 `extern char **environ;` 으로 선언된 전역 변수를 훑으면
 된다. 개별로 작업할 땐 `getenv`나 `putenv`를 쓸 순 있어도 전체를
 조회할람 저거뿐이다.

## 메모리 배치

```
+-----------------------------------------+  higher address
|              args, environ, ...         |
+-----------------------------------------+
|                  stack                  |
|                   ...                   |
|                                         |
.                                         .
.                   ...                   .
|                  heap                   |
+-----------------------------------------+
|     uninitialized data segment (bss)    | --> initialized with 0 by exec
+-----------------------------------------+--+
|        (initialized) data segment       |  |
+-----------------------------------------+  +--> loaded by exec
|              text segment               |  |
+-----------------------------------------+--+  lower address
```

 `size(1)` 명령어로 각 구역의 크기를 바이트단위로 알 수 있다.

``` bash
size /usr/bin/cc /bin/sh
   text	   data	    bss	    dec	    hex	filename
1025621	  15120	  10600	1051341	 100acd	/usr/bin/cc
 110609	   4816	  11312	 126737	  1ef11	/bin/sh
```

 `dec`, `hex`는 각각 총 합을 10진수와 16진수로 나타낸 것이다.

### Text Segment
 - CPU가 진짜 실행할 명령어들 (어셈블리)
 - 공유 가능
 - 읽기 전용

### (Initialized) Data Segment
 - 구체적으로 초기화되는 변수들

### Uninitialized Data Segement (BSS)
 - BSS: Block Started by Symbol. 고대의 어셈블리 연산자 이름에서 유래.
 - 프로그램 실행 전에 커널이 0 또는 널포인터로 초기화

### Stack
 - 함수가 호출될 때마다 함수 호출 정보와 *자동변수(automatic)*가 저장됨

### Heap
 - 동적 메모리 할당


## 프로세스가 프로세스 생성하기
### `fork`

```c++
#include <unistd.h>
pid_t fork(void);
```

 이 함수는 한번 호출되고 두번 리턴한다. 리턴 값은 다음과 같다.

  - 자식 프로세스: pid 0
  - 부모 프로세스: 자식 프로세스의 pid

 하나의 부모가 여러개의 자식 프로세스를 생성할 수 있고, 어떤
 프로세스가 자기에게 속한 자식의 프로세스 pid를 알아내는 다른 방법이
 없기 때문에, 부모 프로세스의 `fork` 리턴 값은 자식 프로세스의 pid
 값이다.

 pid 0은 항상 커널이 (`/etc/init` 또는 `/sbin/init` 용으로) 사용하고,
 `getppid`로 자신의 부모 프로세스의 pid를 알 수 있으므로 자식에게는
 0을 리턴한다.

 `fork` 가 리턴되고 난 이후에도 부모와 자식 프로세스는 이후의 명령을
 계속 실행한다. 자식은 부모의 **복사본**인데, 부모의 데이터 세그먼트,
 스택, 힙의 복사본을 갖는다. **공유하는게 아니다**. 단, **텍스트
 세그먼트**는 공유한다. 이건 어차피 읽기 전용이라 공유하는게 이득이다.

 근데 이렇게 매번 데이터를 복사하는건 엄청난 비효율이고, 특히 `fork`의
 practice 중 하나는 후에 곧바로 `exec`를 호출하는 것이기 때문에,
 요새는 이렇게 바로 복사 안한다. 대신 진짜 그 메모리 영역에 데이터를
 쓸 때 복사하는 Copy-On-Write (COW) 최적화 기법을 사용한다.

 `fork` 후에 부모나 자식 중 누가 먼저 실행되는지는 알 수 없다. 순전히
 커널 (스케쥴링) 마음이다.

 부모의 모든 (open된) 파일 디스크립터는 자식에게 **복제(duplicate)**
 된다. `dup` 함수를 호출한 것과 같은 효과다. 따라서 부모와 자식은
 **동일한 파일 오프셋**을 공유한다. 그래서 fork 되고 나서
 디스크립터들을 잘 처리하려면 다음과 같이 해주는게 좋다.

  - 부모가 자식의 완료를 기다린다. 즉 부모는 디스크립터에 딱히 쓰거나
    읽는 작업을 안한다. 이러면 자식이 종료되는 시점에 자식이
    디스크립터에 쓰거나 읽은 내용은 이미 적절히 오프셋에 반영된다.
  - 부모와 자식이 각자 디스크립터로 작업을 진행하되, 필요없는
    디스크립터는 닫는다. 즉, 프로세스가 서로 간섭하지 않도록 한다.


 파일 디스크립터 외에 자식에게 물려주는 속성은 다음과 같다.
  - 사용자 id, 그룹 id, 등
  - 프로세스 그룹 id
  - 제어 터미널
  - 현재 작업 디렉토리, 루트 디렉토리
  - *공유 메모리 구역들*
  - *메모리 매핑*

 서로 다른 속성은 다음과 같다.
  - fork 리턴값, 각자의 pid
  - 자식의 `tms_utime`, `tms_stime`, `tms_cutime`, `tms_cstime`은 모두
    0으로 초기화
  - 부모의 락은 상속 안됨

### `vfork`
 fork랑 비슷한데 **부모의 주소 공간을 자식에게 복사하지 않는다**는
 차이점이 있다. 보통 `vfork` 후에 곧바로 `exec`를 하는 경우에
 쓰인다. 즉, 자식은 주소 공간이 딱히 필요없이 다른 프로그램에 제어권을
 넘겨주고 죽을 때 쓰인다. 그리고 `vfork`는 항상 **자식이 먼저
 실행됨**을 보장한다.
